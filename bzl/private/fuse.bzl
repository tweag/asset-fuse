load("@bazel_tools//tools/build_defs/repo:local.bzl", "local_repository", "new_local_repository")
load(":fallback.bzl", "bazel_downloader_fallback")

def _fuse_impl(module_ctx):
    mounter = module_ctx.which("asset-fuse")
    if mounter == None:
        fail("asset-fuse needs to be installed in the PATH")

    root_module_direct_deps = []
    root_module_direct_dev_deps = []
    mounts = {}
    for module in module_ctx.modules:
        for mount in module.tags.mount:
            if mount.dev_dependency:
                root_module_direct_dev_deps.append(mount.name)
            else:
                root_module_direct_deps.append(mount.name)
            if not module.is_root:
                fail("only the root module is allowed to add mounts")
            if mount.name in mounts:
                fail("mount point %s is specified more than once" % mount.name)
            mounts[mount.name] = mount

    for name, mount in mounts.items():
        # we have to re-evaluate whenever the manifest changes
        module_ctx.watch(mount.manifest)

        # absolutize the mount point path
        if len(mount.mountpoint) == 0:
            fail("invalid mount point %s" % name)
        mountpoint_abs = mount.mountpoint
        if mountpoint_abs[0] == "~":
            # replace tilde with user's home directory
            mountpoint_abs = module_ctx.getenv("HOME") + mountpoint_abs[1:]
        elif mountpoint_abs[0] == "/":
            # already an absolute path
            pass
        else:
            # workspace-root-relative path
            root_module_path = module_ctx.path(Label("@@//:MODULE.bazel")).dirname
            mountpoint_abs = root_module_path.get_child(mountpoint_abs)

        check_result = module_ctx.execute([mounter, "mount", "--manifest", module_ctx.path(mount.manifest), "--check", mountpoint_abs])
        if check_result.return_code == 0:
            module_ctx.report_progress("{} is mounted. Symlinking repository.".format(mountpoint_abs))

            # check if we should generate a build file / repo boundary:
            if mountpoint_abs.get_child("REPO.bazel").exists and (
                mountpoint_abs.get_child("BUILD").exists or
                mountpoint_abs.get_child("BUILD.bazel").exists
            ):
                local_repository(
                    name = name,
                    path = "{}".format(mountpoint_abs),
                )
            else:
                # should generate BUILD file and boundary marker
                new_local_repository(
                    name = name,
                    build_file_content = "# generated by asset-fuse\nexports_files(glob([\"**\"]))\n",
                    path = "{}".format(mountpoint_abs),
                )
        else:
            if mount.strict:
                fail("mount check for {} failed and strict mode is set: {}\nIf you see this message after mounting the filesystem, you can manually invalidate the module extension evaluation by running bazel shutdown".format(mount.name, check_result.stderr))
            module_ctx.report_progress("{} is not mounted. Downloading with Bazel. This is slow.".format(mountpoint_abs))
            bazel_downloader_fallback(
                name = name,
                manifest = mount.manifest,
            )

_fuse_doc = """Maps a local asset-fuse mount as an external repository, with a fallback to Bazel's downloader if the mount is missing.

Examples:
  Suppose your code depends on a collection of large assets that are used during code generation or testing. Those assets are referenced in a asset-fuse manifest.

  In a separate terminal, mount the asset-fuse filesystem: `asset-fuse mount <path/to/mountpoint>`.
  Alternatively, systems without the ability to mount the FUSE filesystem can skip this step.
  As a fallback, Bazel's downloader can be used (resulting in worse perormance, but identical behavior).

  Targets in the main repository can depend on this target if the
  following lines are added to `MODULE.bazel`:

  ```starlark
  fuse = use_extension("@asset-fuse//bzl:fuse.bzl", "fuse")
  fuse.mount(
      name = "trainingdata",
      mountpoint = "mnt",
      manifest = "//:manifest.json",
  )
  ```
  The optional attribute `strict` can be set to fail the module extension when the mount is not available.
  This is useful if you never want to materialize large files on the system running Bazel.

  Then targets would specify labels like `@trainingdata//:trainingdata/model/very_large.bin` as a dependency.
"""

_mount_attrs = {
    "name": attr.string(
        doc = "Name of the repository",
        mandatory = True,
    ),
    "mountpoint": attr.string(
        doc = "Path of the mountpoint. A relative path is relative to the workspace root. A path prefixed with tilde (~) is relative to the user's home. An absolute path is used as-is.",
    ),
    "manifest": attr.label(
        doc = "The asset-fuse manifest JSON file.",
        mandatory = True,
    ),
    "strict": attr.bool(
        doc = "If set, enforces the existence of the mount point. Otherwise, we will fall back to downloading files referenced in the manifest with Bazel's downloader.",
        default = False,
    ),
    "dev_dependency": attr.bool(
        doc = "If true, this dependency will be ignored if the current module is not the root module or `--ignore_dev_dependency` is enabled.",
    ),
}

_mount_tag = tag_class(
    attrs = _mount_attrs,
)

fuse = module_extension(
    implementation = _fuse_impl,
    tag_classes = {
        "mount": _mount_tag,
    },
    doc = _fuse_doc,
)
